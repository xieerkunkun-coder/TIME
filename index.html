<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3-2-1 专注视觉计时器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevent scroll on mobile while dragging */
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* 3-2-1 Animation Overlay */
        #countdown-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 40; 
            justify-content: center;
            align-items: center;
            pointer-events: none;
            
            background: rgba(255, 255, 255, 0.05); 
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        /* Dark mode overlay adjustment */
        html.dark #countdown-overlay {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .countdown-number {
            font-size: 10rem; 
            font-weight: 900;
            /* Colors handled in JS */
            animation: pulse-scale 0.9s ease-out infinite;
            letter-spacing: -0.05em;
        }

        @keyframes pulse-scale {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.1); opacity: 1; } 
            100% { transform: scale(1); opacity: 0; }
        }

        /* Alarm Flash Animation */
        .alarm-flash {
            animation: flash-bg 0.5s infinite alternate ease-in-out;
        }

        @keyframes flash-bg {
            from { background-color: #fee2e2; } /* Light Red */
            to { background-color: #ef4444; } /* Strong Red */
        }
        
        /* Dark mode alarm flash */
        html.dark .alarm-flash {
            animation: flash-bg-dark 0.5s infinite alternate ease-in-out;
        }

        @keyframes flash-bg-dark {
            from { background-color: #7f1d1d; } /* Dark Red */
            to { background-color: #b91c1c; } /* Brighter Red */
        }
        
        /* Text Flash Animation */
        .text-flash {
            animation: flash-text 0.5s infinite alternate ease-in-out;
        }
        
        @keyframes flash-text {
            from { opacity: 0.5; transform: scale(1); }
            to { opacity: 1; transform: scale(1.1); }
        }

        /* Knob Cursor */
        .grab-cursor { cursor: grab; }
        .grabbing-cursor { cursor: grabbing; }

        /* Settings Modal Transition */
        #settings-modal {
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        #settings-modal.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            display: flex !important; /* Keep flex for transition logic */
            visibility: hidden;
        }
        #settings-modal:not(.hidden) {
            opacity: 1;
            transform: scale(1);
            visibility: visible;
        }
        
        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%; 
            background: transparent; 
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #94a3b8;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        html.dark input[type=range]::-webkit-slider-thumb {
            background: #cbd5e1;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }
        
        html.dark input[type=range]::-webkit-slider-runnable-track {
            background: #334155;
        }

        input[type=range]:focus {
            outline: none;
        }

        /* Toggle Switch Colors for BOOM & Minute & Scale */
        .toggle-boom:checked { background-color: #f59e0b; }
        .toggle-minute:checked { background-color: #6366f1; } 
        .toggle-scale:checked { background-color: #10b981; } 

        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="h-screen w-full flex flex-col items-center justify-between py-12 text-slate-800 bg-slate-50 dark:bg-slate-950 dark:text-slate-200 relative overflow-hidden transition-colors duration-500">

    <!-- Header / Settings Button -->
    <div class="absolute top-6 right-6 z-50">
        <button id="settings-btn" class="p-3 bg-white dark:bg-slate-800 rounded-full shadow-sm hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors text-slate-400 dark:text-slate-500">
            <!-- Gear Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>
    </div>

    <!-- Main Content Wrapper -->
    <div class="flex-1 flex flex-col items-center justify-center w-full max-w-sm px-4">
        
        <!-- Status Text -->
        <div id="status-text" class="text-2xl font-semibold text-slate-300 dark:text-slate-600 mb-8 h-16 flex items-center justify-center transition-all duration-300 tracking-widest uppercase text-center">
            准备就绪
        </div>

        <!-- Timer Canvas Container -->
        <div class="relative w-[340px] h-[340px] mb-12 shadow-[0_20px_50px_-12px_rgba(0,0,0,0.1)] dark:shadow-[0_20px_50px_-12px_rgba(0,0,0,0.3)] rounded-full bg-white dark:bg-slate-800 flex items-center justify-center ring-1 ring-slate-100 dark:ring-slate-700 transition-colors duration-500">
            <canvas id="timerCanvas" width="340" height="340" class="absolute top-0 left-0 cursor-pointer rounded-full"></canvas>
            
            <!-- Digital Display Center (Opacity dynamic) -->
            <div class="flex flex-col items-center justify-center pointer-events-none z-10">
                <div id="time-display" class="font-bold text-black dark:text-white tabular-nums tracking-tighter transition-colors duration-500" style="opacity: 0.45; font-size: 4.5rem;">
                    25:00
                </div>
                <!-- Overtime display -->
                <div id="overtime-display" class="hidden flex-col items-center mt-2 animate-pulse opacity-50">
                    <span class="text-[10px] uppercase font-bold tracking-widest dynamic-text-color">OVERTIME</span>
                    <span id="overtime-counter" class="text-xl font-bold tabular-nums dynamic-text-color">+00:00</span>
                </div>
            </div>
        </div>

        <!-- Start/Pause/Reset Button -->
        <button id="main-action-btn" class="rounded-full text-white shadow-xl flex items-center justify-center transition-all transform duration-200 active:scale-95 mt-10" style="opacity: 0.2; width: 90px; height: 90px;">
            <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
            </svg>
            <svg id="icon-stop" xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 hidden" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" />
            </svg>
        </button>

    </div>

    <!-- 3-2-1 Overlay -->
    <div id="countdown-overlay">
        <div id="countdown-text" class="countdown-number">3</div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black/20 backdrop-blur-sm z-50 flex items-center justify-center hidden">
        <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 w-72 transform transition-all border border-slate-100 dark:border-slate-700 max-h-[90vh] overflow-y-auto relative">
            
            <!-- MAIN VIEW -->
            <div id="settings-main-view" class="transition-opacity duration-300">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-lg font-bold text-slate-700 dark:text-slate-200">设置</h3>
                    <button id="close-settings" class="text-slate-400 hover:text-slate-600 dark:hover:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <!-- Sound Toggle -->
                <div class="flex items-center justify-between mb-5">
                    <span class="text-slate-600 dark:text-slate-300 font-medium">提示音</span>
                    <button id="modal-sound-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none bg-slate-200 dark:bg-slate-600">
                        <span id="sound-toggle-knob" class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-sm"></span>
                    </button>
                </div>
                
                <!-- Dark Mode Toggle -->
                <div class="flex items-center justify-between mb-5">
                    <span class="text-slate-600 dark:text-slate-300 font-medium">深色模式</span>
                    <button id="modal-dark-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none bg-slate-200 dark:bg-slate-600">
                        <span id="dark-toggle-knob" class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-sm"></span>
                    </button>
                </div>

                <!-- BOOM Mode Toggle -->
                <div class="flex items-center justify-between mb-5">
                    <div class="flex flex-col">
                        <span class="text-slate-600 dark:text-slate-300 font-medium font-bold">BOOM 模式</span>
                        <span class="text-[10px] text-slate-400 dark:text-slate-500">180分钟 · 三色分级</span>
                    </div>
                    <button id="modal-boom-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none bg-slate-200 dark:bg-slate-600">
                        <span id="boom-toggle-knob" class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-sm"></span>
                    </button>
                </div>

                <!-- Minute Mode Toggle -->
                <div class="flex items-center justify-between mb-5">
                    <div class="flex flex-col">
                        <span class="text-slate-600 dark:text-slate-300 font-medium font-bold">分针模式</span>
                        <span class="text-[10px] text-slate-400 dark:text-slate-500">显示60个分钟刻度</span>
                    </div>
                    <button id="modal-minute-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none bg-slate-200 dark:bg-slate-600">
                        <span id="minute-toggle-knob" class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-sm"></span>
                    </button>
                </div>

                <!-- Color Picker -->
                <div id="color-picker-container" class="mb-5 border-t border-slate-100 dark:border-slate-700 pt-5 transition-opacity duration-300">
                    <div class="text-slate-600 dark:text-slate-300 font-medium mb-3">表盘颜色</div>
                    <div class="flex justify-between gap-2">
                        <button class="color-btn w-12 h-12 rounded-full bg-red-500 hover:scale-110 transition-transform ring-offset-2 ring-red-300 dark:ring-red-900 focus:ring-2" data-color="red" data-hex="#ef4444"></button>
                        <button class="color-btn w-12 h-12 rounded-full bg-yellow-400 hover:scale-110 transition-transform ring-offset-2 ring-yellow-300 dark:ring-yellow-700 focus:ring-2" data-color="yellow" data-hex="#facc15"></button>
                        <button class="color-btn w-12 h-12 rounded-full bg-blue-500 hover:scale-110 transition-transform ring-offset-2 ring-blue-300 dark:ring-blue-900 focus:ring-2" data-color="blue" data-hex="#3b82f6"></button>
                    </div>
                </div>

                <!-- Link to Interface Adjustments -->
                <div class="mb-5 border-t border-slate-100 dark:border-slate-700 pt-5">
                    <button id="goto-interface-btn" class="w-full flex justify-between items-center text-slate-600 dark:text-slate-300 font-medium hover:bg-slate-50 dark:hover:bg-slate-700/50 p-2 -ml-2 rounded-lg transition-colors">
                        <span>界面调节</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                </div>
                
                <!-- Restore Default Button -->
                <div class="pt-2 border-t border-slate-100 dark:border-slate-700">
                    <button id="restore-default-btn" class="w-full py-3 text-sm font-medium text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200 transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                        恢复默认设置
                    </button>
                </div>
            </div>

            <!-- INTERFACE SUB-VIEW (Hidden by default) -->
            <div id="settings-interface-view" class="hidden transition-opacity duration-300">
                <div class="flex justify-between items-center mb-6">
                    <button id="back-to-main-btn" class="text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200 flex items-center gap-1 text-sm font-medium">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                        返回
                    </button>
                    <h3 class="text-lg font-bold text-slate-700 dark:text-slate-200">界面调节</h3>
                    <div class="w-8"></div> <!-- Spacer for centering -->
                </div>

                <!-- Scale Position Toggle -->
                <div class="flex items-center justify-between mb-5">
                    <div class="flex flex-col">
                        <span class="text-slate-600 dark:text-slate-300 font-medium">刻度显示</span>
                        <span id="scale-label" class="text-[10px] text-slate-400 dark:text-slate-500">当前: 内侧</span>
                    </div>
                    <button id="modal-scale-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none bg-slate-200 dark:bg-slate-600">
                        <span id="scale-toggle-knob" class="translate-x-1 inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-sm"></span>
                    </button>
                </div>

                <!-- Sliders -->
                <div class="mb-5 border-t border-slate-100 dark:border-slate-700 pt-5">
                    <!-- Time Font Size -->
                    <div class="mb-4">
                        <div class="flex justify-between mb-1">
                            <span class="text-sm text-slate-600 dark:text-slate-300">中心数字大小</span>
                            <span id="size-time-val" class="text-xs text-slate-400 font-mono">4.5rem</span>
                        </div>
                        <input type="range" id="size-time-slider" min="20" max="80" value="45" class="w-full">
                    </div>

                    <!-- Button Size -->
                    <div class="mb-4">
                        <div class="flex justify-between mb-1">
                            <span class="text-sm text-slate-600 dark:text-slate-300">开关按钮大小</span>
                            <span id="size-btn-val" class="text-xs text-slate-400 font-mono">90px</span>
                        </div>
                        <input type="range" id="size-btn-slider" min="60" max="140" value="90" class="w-full">
                    </div>

                    <!-- Opacity Sliders -->
                    <div class="mb-4">
                        <div class="flex justify-between mb-1">
                            <span class="text-sm text-slate-600 dark:text-slate-300">数字透明度</span>
                            <span id="opacity-time-val" class="text-xs text-slate-400 font-mono">45%</span>
                        </div>
                        <input type="range" id="opacity-time-slider" min="0" max="100" value="45" class="w-full">
                    </div>

                    <div>
                        <div class="flex justify-between mb-1">
                            <span class="text-sm text-slate-600 dark:text-slate-300">按钮透明度</span>
                            <span id="opacity-btn-val" class="text-xs text-slate-400 font-mono">20%</span>
                        </div>
                        <input type="range" id="opacity-btn-slider" min="20" max="100" value="20" class="w-full">
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const canvas = document.getElementById('timerCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        
        const radius = 150; 
        
        const themes = {
            red: { main: '#ef4444', light: '#fca5a5', shadow: 'shadow-red-200', text: 'text-red-500' },
            yellow: { main: '#facc15', light: '#fde047', shadow: 'shadow-yellow-200', text: 'text-yellow-500' },
            blue: { main: '#3b82f6', light: '#93c5fd', shadow: 'shadow-blue-200', text: 'text-blue-500' }
        };
        
        const boomColors = {
            layer1: '#ef4444', // Red (0-60)
            layer2: '#facc15', // Yellow (60-120)
            layer3: '#3b82f6'  // Blue (120-180)
        };

        let currentTheme = 'red';
        let totalSeconds = 25 * 60; 
        let initialSeconds = 25 * 60; 
        
        let isRunning = false;
        let isOvertime = false;
        let isWarmingUp = false; 
        let isDarkMode = false;
        let isBoomMode = false;
        let isMinuteMode = false; 
        
        let tickPosition = 'inner'; // 'inner' or 'outer'
        
        let timeDisplayOpacity = 0.45;
        let mainBtnOpacity = 0.2; // Changed default to 0.2 (20%)
        let timeFontSize = 4.5; 
        let mainBtnSize = 90; 
        
        let isDragging = false;
        let prevDragAngle = 0;
        
        let overtimeCount = 0;
        let timerInterval = null;
        let warmupFrameId = null;
        let alarmInterval = null;
        let alarmTimeout = null;
        let alarmStartTime = 0;
        
        let timerStartTime = 0; 

        let soundEnabled = true;
        let audioCtx;

        // --- Elements ---
        const timeDisplay = document.getElementById('time-display');
        const statusText = document.getElementById('status-text');
        const mainBtn = document.getElementById('main-action-btn');
        const iconPlay = document.getElementById('icon-play');
        const iconStop = document.getElementById('icon-stop');
        
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings');
        const restoreDefaultBtn = document.getElementById('restore-default-btn');
        
        // Modal Views
        const mainSettingsView = document.getElementById('settings-main-view');
        const interfaceSettingsView = document.getElementById('settings-interface-view');
        const gotoInterfaceBtn = document.getElementById('goto-interface-btn');
        const backToMainBtn = document.getElementById('back-to-main-btn');
        
        const modalSoundToggle = document.getElementById('modal-sound-toggle');
        const soundToggleKnob = document.getElementById('sound-toggle-knob');
        
        const modalDarkToggle = document.getElementById('modal-dark-toggle');
        const darkToggleKnob = document.getElementById('dark-toggle-knob');
        
        const modalBoomToggle = document.getElementById('modal-boom-toggle');
        const boomToggleKnob = document.getElementById('boom-toggle-knob');
        
        const modalMinuteToggle = document.getElementById('modal-minute-toggle');
        const minuteToggleKnob = document.getElementById('minute-toggle-knob');
        
        const modalScaleToggle = document.getElementById('modal-scale-toggle');
        const scaleToggleKnob = document.getElementById('scale-toggle-knob');
        const scaleLabel = document.getElementById('scale-label');
        
        const colorPickerContainer = document.getElementById('color-picker-container');
        
        const opacityTimeSlider = document.getElementById('opacity-time-slider');
        const opacityTimeVal = document.getElementById('opacity-time-val');
        const opacityBtnSlider = document.getElementById('opacity-btn-slider');
        const opacityBtnVal = document.getElementById('opacity-btn-val');
        
        const sizeTimeSlider = document.getElementById('size-time-slider');
        const sizeTimeVal = document.getElementById('size-time-val');
        const sizeBtnSlider = document.getElementById('size-btn-slider');
        const sizeBtnVal = document.getElementById('size-btn-val');
        
        const colorBtns = document.querySelectorAll('.color-btn');

        const overtimeDisplay = document.getElementById('overtime-display');
        const overtimeCounter = document.getElementById('overtime-counter');
        const overlay = document.getElementById('countdown-overlay');
        const countdownText = document.getElementById('countdown-text');

        // --- Initialization ---
        function init() {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                toggleDarkMode(true);
            }
            
            // Sync initial slider values
            opacityTimeSlider.value = timeDisplayOpacity * 100;
            opacityBtnSlider.value = mainBtnOpacity * 100;
            sizeTimeSlider.value = timeFontSize * 10;
            sizeBtnSlider.value = mainBtnSize;
            
            updateOpacityLabels();
            updateSizeLabels();
            
            updateThemeColors();
            drawTimer();
            updateDisplay();
            updateSoundToggleUI();
            updateDarkToggleUI();
            updateBoomToggleUI();
            updateMinuteToggleUI();
            updateScaleToggleUI();
            
            applyOpacities();
            applySizes();
            
            requestAnimationFrame(animationLoop);
        }
        
        function animationLoop() {
            if (isRunning && isMinuteMode) {
                drawTimer();
            }
            requestAnimationFrame(animationLoop);
        }
        
        function applyOpacities() {
            timeDisplay.style.opacity = timeDisplayOpacity;
            mainBtn.style.opacity = mainBtnOpacity;
        }
        
        function applySizes() {
            timeDisplay.style.fontSize = timeFontSize + 'rem';
            mainBtn.style.width = mainBtnSize + 'px';
            mainBtn.style.height = mainBtnSize + 'px';
        }
        
        function updateOpacityLabels() {
            opacityTimeVal.textContent = Math.round(timeDisplayOpacity * 100) + '%';
            opacityBtnVal.textContent = Math.round(mainBtnOpacity * 100) + '%';
        }
        
        function updateSizeLabels() {
            sizeTimeVal.textContent = timeFontSize + 'rem';
            sizeBtnVal.textContent = mainBtnSize + 'px';
        }
        
        // Helper to update font size logic consistently
        function updateFontSizeByMode() {
            if (isBoomMode && isMinuteMode) {
                timeFontSize = 2.2;
            } else if (isMinuteMode) {
                timeFontSize = 2.6;
            } else {
                timeFontSize = 4.5;
            }
            
            // Update slider UI
            sizeTimeSlider.value = timeFontSize * 10;
            updateSizeLabels();
            applySizes();
        }
        
        function switchSettingsView(view) {
            if (view === 'interface') {
                mainSettingsView.classList.add('hidden');
                interfaceSettingsView.classList.remove('hidden');
            } else {
                interfaceSettingsView.classList.add('hidden');
                mainSettingsView.classList.remove('hidden');
            }
        }
        
        function resetToDefaults() {
            currentTheme = 'red';
            soundEnabled = true;
            isDarkMode = false;
            isBoomMode = false;
            isMinuteMode = false;
            tickPosition = 'inner';
            timeDisplayOpacity = 0.45;
            mainBtnOpacity = 0.2; // Changed default to 0.2
            timeFontSize = 4.5;
            mainBtnSize = 90;
            
            // Reset logic
            document.documentElement.classList.remove('dark');
            colorPickerContainer.classList.remove('opacity-50', 'pointer-events-none');
            
            // Update sliders
            opacityTimeSlider.value = 45;
            opacityBtnSlider.value = 20; // Changed default slider value to 20
            sizeTimeSlider.value = 45; 
            sizeBtnSlider.value = 90;
            
            // Reset Views
            switchSettingsView('main');
            
            updateOpacityLabels();
            updateSizeLabels();
            updateSoundToggleUI();
            updateDarkToggleUI();
            updateBoomToggleUI();
            updateMinuteToggleUI();
            updateScaleToggleUI();
            
            updateThemeColors();
            applySizes();
            applyOpacities();
            drawTimer();
            
            // Re-highlight color btn
            colorBtns.forEach(b => b.classList.remove('ring-2', 'ring-offset-2', 'dark:ring-offset-slate-800'));
            // Assuming red is first
            const redBtn = document.querySelector('[data-color="red"]');
            if(redBtn) redBtn.classList.add('ring-2', 'ring-offset-2', 'dark:ring-offset-slate-800');
        }

        // --- Theme & Logic ---
        function updateThemeColors() {
            let activeColorHex, activeShadow, activeThemeName;
            
            if (isBoomMode) {
                if (totalSeconds > 120 * 60) {
                    activeColorHex = boomColors.layer3; 
                    activeShadow = 'shadow-blue-200';
                    activeThemeName = 'blue';
                } else if (totalSeconds > 60 * 60) {
                    activeColorHex = boomColors.layer2; 
                    activeShadow = 'shadow-yellow-200';
                    activeThemeName = 'yellow';
                } else {
                    activeColorHex = boomColors.layer1; 
                    activeShadow = 'shadow-red-200';
                    activeThemeName = 'red';
                }
            } else {
                const theme = themes[currentTheme];
                activeColorHex = theme.main;
                activeShadow = theme.shadow;
                activeThemeName = currentTheme;
            }
            
            if (!isRunning && !isOvertime && !isWarmingUp) {
                if (isBoomMode) {
                    mainBtn.className = 'rounded-full text-white shadow-xl flex items-center justify-center transition-all transform duration-200 active:scale-95 mt-10 bg-black hover:bg-gray-900 shadow-slate-400 dark:shadow-slate-900';
                } else if (isDarkMode) {
                    mainBtn.className = `rounded-full text-white shadow-xl flex items-center justify-center transition-all transform duration-200 active:scale-95 mt-10 bg-slate-800 hover:bg-slate-700 shadow-slate-900`;
                } else {
                    let bgClass = '';
                    if (activeThemeName === 'red') bgClass = 'bg-red-500 hover:brightness-110';
                    else if (activeThemeName === 'yellow') bgClass = 'bg-yellow-400 hover:brightness-110';
                    else if (activeThemeName === 'blue') bgClass = 'bg-blue-500 hover:brightness-110';
                    
                    mainBtn.className = `rounded-full text-white shadow-xl flex items-center justify-center transition-all transform duration-200 active:scale-95 mt-10 ${bgClass} ${activeShadow}`;
                }
            }

            document.querySelectorAll('.dynamic-text-color').forEach(el => {
                el.style.color = activeColorHex;
            });
            
            applyOpacities();
            applySizes();
            drawTimer();
        }

        function setTheme(colorName) {
            currentTheme = colorName;
            updateThemeColors();
        }
        
        function toggleDarkMode(forceState = null) {
            if (forceState !== null) isDarkMode = forceState;
            else isDarkMode = !isDarkMode;
            
            if (isDarkMode) document.documentElement.classList.add('dark');
            else document.documentElement.classList.remove('dark');
            
            updateDarkToggleUI();
            updateThemeColors(); 
            drawTimer();
        }
        
        function toggleBoomMode() {
            isBoomMode = !isBoomMode;
            if (!isBoomMode && totalSeconds > 3600) {
                totalSeconds = 3600;
                initialSeconds = 3600;
                updateDisplay();
            }
            if (isBoomMode) colorPickerContainer.classList.add('opacity-50', 'pointer-events-none');
            else colorPickerContainer.classList.remove('opacity-50', 'pointer-events-none');
            
            updateBoomToggleUI();
            updateFontSizeByMode(); 
            updateThemeColors();
        }
        
        function toggleMinuteMode() {
            isMinuteMode = !isMinuteMode;
            
            updateFontSizeByMode(); 
            
            updateMinuteToggleUI();
            drawTimer();
        }
        
        function toggleScalePosition() {
            tickPosition = tickPosition === 'inner' ? 'outer' : 'inner';
            updateScaleToggleUI();
            drawTimer();
        }

        // --- Drawing Logic ---
        
        function drawRingSegment(startAngle, endAngle, color) {
            const innerRadius = radius * 0.4; 
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
            ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true); 
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        function drawFullRing(color) {
            drawRingSegment(0, 2 * Math.PI, color);
        }

        function drawTimer(warmupAngle = null, overrideSeconds = null) {
            const theme = themes[currentTheme];
            ctx.clearRect(0, 0, width, height);

            // 1. Draw Dial Background
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = isDarkMode ? '#1e293b' : '#f8fafc'; 
            ctx.fill();
            
            // 2. Draw Tick Marks
            // Logic: Inner (Default) -> Draw inside radius (150). e.g. 140-150.
            //        Outer -> Draw outside radius 150. e.g. 155-165. (Canvas has space, center 170, radius 150)
            
            const tickStartR = tickPosition === 'inner' ? radius - 10 : radius + 15;
            const tickEndR   = tickPosition === 'inner' ? radius : radius + 5;
            // Actually 'Outer' implies marks closer to the white bezel edge.
            // Center 170. Radius 150. Gap 20px. 
            // Let's make Outer ticks at 155-165.
            
            for (let i = 0; i < 60; i++) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate((i * 6) * Math.PI / 180);
                ctx.beginPath();
                ctx.moveTo(0, -tickStartR); 
                ctx.lineTo(0, -tickEndR);
                
                ctx.lineWidth = i % 5 === 0 ? 3 : 1; 
                
                // Reverting to lighter colors as requested
                // Light Mode: Major -> Slate 300 (#cbd5e1), Minor -> Slate 200 (#e2e8f0)
                // Dark Mode: Major -> Slate 500 (#64748b), Minor -> Slate 700 (#334155)
                if (isDarkMode) {
                     ctx.strokeStyle = i % 5 === 0 ? '#64748b' : '#334155';
                } else {
                     ctx.strokeStyle = i % 5 === 0 ? '#cbd5e1' : '#e2e8f0';
                }
                
                ctx.stroke();
                ctx.restore();
            }

            // Determine time to render
            let secondsToRender = totalSeconds;
            if (overrideSeconds !== null) {
                secondsToRender = overrideSeconds;
            }

            // Determine Active Color
            let activeColor;
            if (isBoomMode) {
                if (secondsToRender > 120 * 60) activeColor = boomColors.layer3;
                else if (secondsToRender > 60 * 60) activeColor = boomColors.layer2;
                else activeColor = boomColors.layer1;
            } else {
                activeColor = themes[currentTheme].main;
            }

            // --- 3. DRAWING LAYERS ---

            // A) WARMUP
            if (isWarmingUp && warmupAngle !== null) {
                if (isMinuteMode) {
                    drawRingSegment(-0.5 * Math.PI, warmupAngle - 0.5 * Math.PI, activeColor);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, -0.5 * Math.PI, warmupAngle - 0.5 * Math.PI, false); 
                    ctx.fillStyle = activeColor; 
                    ctx.fill();
                    ctx.closePath();
                }
                
                const knobX = centerX + radius * Math.cos(warmupAngle - 0.5 * Math.PI);
                const knobY = centerY + radius * Math.sin(warmupAngle - 0.5 * Math.PI);
                drawKnob(knobX, knobY, activeColor, isMinuteMode ? 12 : 14);
                return;
            } 

            // B) MAIN TIMER
            if ((totalSeconds > 0 || overrideSeconds !== null) && !isOvertime) {
                
                // Draw Underlying Layers for BOOM (Skip in Minute Mode)
                if (isBoomMode && !isMinuteMode) {
                    if (secondsToRender > 60 * 60) {
                        ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.fillStyle = boomColors.layer1; ctx.fill();
                    }
                    if (secondsToRender > 120 * 60) {
                        ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.fillStyle = boomColors.layer2; ctx.fill();
                    }
                }

                let secondsToDrawLayer = secondsToRender;
                if (isBoomMode) {
                    if (secondsToRender > 120 * 60) secondsToDrawLayer = secondsToRender - 7200;
                    else if (secondsToRender > 60 * 60) secondsToDrawLayer = secondsToRender - 3600;
                }
                
                if (isMinuteMode) {
                    drawMinuteSegments(secondsToDrawLayer, activeColor);
                    
                    let knobAngle;
                    if (secondsToDrawLayer > 0) {
                        const numSegments = Math.ceil(secondsToDrawLayer / 60);
                        const segmentAngle = (2 * Math.PI / 60);
                        const gap = 0.03; 
                        
                        knobAngle = -0.5 * Math.PI + (numSegments - 1) * segmentAngle + (segmentAngle - gap) / 2;
                    } else {
                        knobAngle = -0.5 * Math.PI;
                    }
                    
                    const knobX = centerX + radius * Math.cos(knobAngle);
                    const knobY = centerY + radius * Math.sin(knobAngle);
                    drawKnob(knobX, knobY, activeColor, 12); 
                    
                } else {
                    const percent = secondsToDrawLayer / 3600;
                    const endAngle = (percent * 2 * Math.PI) - (0.5 * Math.PI);
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, -0.5 * Math.PI, endAngle, false); 
                    ctx.fillStyle = activeColor;
                    ctx.fill();
                    ctx.closePath();
                    
                    const knobX = centerX + radius * Math.cos(endAngle);
                    const knobY = centerY + radius * Math.sin(endAngle);
                    drawKnob(knobX, knobY, activeColor, 14); 
                }
            } 
        }
        
        function drawMinuteSegments(seconds, color) {
            const numSegments = Math.ceil(seconds / 60);
            const gap = 0.03; 
            const segmentAngle = (2 * Math.PI / 60);
            const innerRadius = radius * 0.4; 

            // Synced Binary Flash Logic
            const elapsed = isRunning ? (performance.now() - timerStartTime) : 0;
            const isVisible = Math.floor(elapsed / 500) % 2 === 0;

            for (let i = 0; i < numSegments; i++) {
                let startAngle = -0.5 * Math.PI + (i * segmentAngle);
                let endAngle = -0.5 * Math.PI + ((i + 1) * segmentAngle) - gap;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
                ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                ctx.closePath();
                
                if (isRunning && i === numSegments - 1) {
                    if (isVisible) {
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                } else {
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }

        function drawKnob(x, y, color, r = 14) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.fillStyle = isDarkMode ? '#0f172a' : '#ffffff'; 
            ctx.shadowColor = 'rgba(0,0,0,0.15)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetY = 2;
            ctx.fill();
            ctx.strokeStyle = color; 
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.shadowBlur = 0; 
            ctx.shadowOffsetY = 0;
        }

        // --- Helper: Format Time ---
        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateDisplay() {
            timeDisplay.textContent = formatTime(totalSeconds);
            if (isOvertime) {
                overtimeCounter.textContent = "+" + formatTime(overtimeCount);
            }
        }

        // --- Interaction Logic ---
        function getAngle(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left - centerX;
            const y = clientY - rect.top - centerY;
            let theta = Math.atan2(y, x); 
            theta += Math.PI / 2;
            if (theta < 0) theta += 2 * Math.PI;
            return theta;
        }

        function startDrag(e) {
            if (isRunning || isOvertime || isWarmingUp) return;
            isDragging = true;
            document.body.classList.add('grabbing-cursor');
            prevDragAngle = getAngle(e);
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault(); 
            const currentAngle = getAngle(e);
            let delta = currentAngle - prevDragAngle;
            if (delta > Math.PI) delta -= 2 * Math.PI;
            else if (delta < -Math.PI) delta += 2 * Math.PI;
            
            const secondsChange = (delta / (2 * Math.PI)) * 3600;
            let newTotal = totalSeconds + secondsChange;
            const maxSecs = (isBoomMode ? 180 : 60) * 60;
            
            if (newTotal < 0) newTotal = 0;
            if (newTotal > maxSecs) newTotal = maxSecs;
            
            totalSeconds = newTotal; 
            initialSeconds = newTotal; 
            prevDragAngle = currentAngle;
            
            drawTimer();
            updateDisplayRounded();
            statusText.textContent = "设定时间";
            if (isBoomMode) updateThemeColors();
        }
        
        function updateDisplayRounded() {
            let snapped = Math.round(totalSeconds / 30) * 30;
            timeDisplay.textContent = formatTime(snapped);
        }

        function endDrag() {
            isDragging = false;
            document.body.classList.remove('grabbing-cursor');
            totalSeconds = Math.round(totalSeconds / 30) * 30;
            initialSeconds = totalSeconds; // Sync
            updateDisplay();
            drawTimer();
        }

        canvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', drag);
        window.addEventListener('mouseup', endDrag);
        canvas.addEventListener('touchstart', startDrag, { passive: false });
        window.addEventListener('touchmove', drag, { passive: false });
        window.addEventListener('touchend', endDrag);


        // --- Warmup & Timer Logic ---
        function startWarmupSequence() {
            if (totalSeconds <= 0) return;
            initAudio();
            isWarmingUp = true;
            updateUIState(); 
            statusText.style.visibility = 'hidden';
            overlay.style.display = 'flex'; 
            countdownText.style.color = isDarkMode ? "#e2e8f0" : "#334155"; 
            countdownText.style.fontSize = "10rem";
            
            const totalCycles = 3;
            const msPerCycle = 1000; 
            const startTimestamp = performance.now();
            let lastCycleIndex = -1;

            function frame(now) {
                if (!isWarmingUp) return; 
                const elapsed = now - startTimestamp;
                const totalProgress = elapsed / msPerCycle; 
                const currentCycleIndex = Math.floor(totalProgress); 
                const countdownNum = 3 - currentCycleIndex;

                if (currentCycleIndex > lastCycleIndex && currentCycleIndex < totalCycles) {
                    playBeep(440, 0.5); 
                    countdownText.style.animation = 'none';
                    countdownText.offsetHeight; 
                    countdownText.style.animation = 'pulse-scale 0.9s ease-out infinite';
                    countdownText.textContent = countdownNum;
                    lastCycleIndex = currentCycleIndex;
                }

                if (totalProgress >= totalCycles) {
                    finishWarmup();
                } else {
                    const cycleProgress = totalProgress % 1; 
                    const angle = cycleProgress * 2 * Math.PI;
                    drawTimer(angle);
                    warmupFrameId = requestAnimationFrame(frame);
                }
            }
            warmupFrameId = requestAnimationFrame(frame);
        }

        function animateToSetTime(duration) {
            const startTimestamp = performance.now();
            
            function frame(now) {
                if (!isWarmingUp) return;
                
                const elapsed = now - startTimestamp;
                const progress = Math.min(elapsed / duration, 1);
                
                const ease = 1 - Math.pow(1 - progress, 3);
                
                const currentAnimatedSeconds = ease * totalSeconds;
                
                drawTimer(null, currentAnimatedSeconds);
                
                if (progress < 1) {
                    warmupFrameId = requestAnimationFrame(frame);
                }
            }
            warmupFrameId = requestAnimationFrame(frame);
        }

        function finishWarmup() {
            cancelAnimationFrame(warmupFrameId);
            const txt = document.getElementById('countdown-text');
            txt.textContent = "GO!";
            txt.style.fontSize = "13rem"; 
            txt.style.color = isDarkMode ? "#ffffff" : "#334155"; 
            txt.style.animation = 'none';
            txt.offsetHeight; 
            txt.style.animation = 'pulse-scale 1s ease-out forwards';
            playBeep(1568, 1.5); 
            
            animateToSetTime(1000); 

            setTimeout(() => {
                if (!isWarmingUp) return; 
                isWarmingUp = false;
                overlay.style.display = 'none';
                startTimer();
            }, 1000);
        }

        function startTimer() {
            isRunning = true;
            timerStartTime = performance.now(); 
            
            updateUIState();
            statusText.style.visibility = 'visible'; 
            statusText.textContent = "专注中!!!";
            let colorClass = 'text-blue-500';
            if(isBoomMode && totalSeconds > 7200) colorClass = 'text-blue-500';
            else if(isBoomMode && totalSeconds > 3600) colorClass = 'text-yellow-500';
            else if(isBoomMode) colorClass = 'text-red-500';
            else {
                 const theme = themes[currentTheme];
                 if(theme.text) colorClass = theme.text;
            }
            statusText.className = `text-2xl font-semibold ${colorClass} mb-8 h-16 flex items-center justify-center tracking-widest uppercase text-center animate-pulse`;
            
            drawTimer(); 

            timerInterval = setInterval(() => {
                if (totalSeconds > 0) {
                    totalSeconds--;
                    drawTimer();
                    updateDisplay();
                    if(isBoomMode) updateThemeColors();
                } else {
                    clearInterval(timerInterval);
                    enterOvertime();
                }
            }, 1000);
        }

        function enterOvertime() {
            isOvertime = true;
            isRunning = false;
            overtimeCount = 0;
            
            if(audioCtx) alarmStartTime = audioCtx.currentTime;
            else alarmStartTime = 0; 

            document.body.classList.add('alarm-flash');
            statusText.textContent = "TIME UP";
            statusText.className = "text-7xl font-black text-red-600 dark:text-red-400 text-flash mb-8 h-16 flex items-center justify-center tracking-tighter shadow-white drop-shadow-lg";
            overtimeDisplay.classList.remove('hidden');
            overtimeDisplay.classList.add('flex');
            
            playAlarmNote(); 
            alarmInterval = setInterval(playAlarmNote, 1000); 
            
            alarmTimeout = setTimeout(() => { stopAlarmEffects(); }, 15000);
            
            timerInterval = setInterval(() => {
                overtimeCount++;
                drawTimer(); 
                updateDisplay();
            }, 1000);
            updateUIState();
        }

        function stopAlarmEffects() {
            if (alarmInterval) clearInterval(alarmInterval);
            document.body.classList.remove('alarm-flash');
            statusText.className = "text-7xl font-black text-red-500 mb-8 h-16 flex items-center justify-center tracking-tighter";
        }

        function stopTimer() {
            clearInterval(timerInterval);
            if (alarmInterval) clearInterval(alarmInterval);
            if (alarmTimeout) clearTimeout(alarmTimeout);
            cancelAnimationFrame(warmupFrameId);
            isRunning = false;
            isOvertime = false;
            isWarmingUp = false;
            overlay.style.display = 'none';
            document.body.classList.remove('alarm-flash');
            overtimeDisplay.classList.add('hidden');
            overtimeDisplay.classList.remove('flex');
            statusText.style.visibility = 'visible';
            statusText.textContent = "暂停";
            statusText.className = "text-2xl font-semibold text-slate-300 dark:text-slate-600 mb-8 h-16 flex items-center justify-center tracking-widest uppercase text-center";
            if (totalSeconds === 0) {
                 totalSeconds = initialSeconds > 0 ? initialSeconds : 1500;
            }
            drawTimer(); 
            updateDisplay();
            updateUIState();
        }

        function updateUIState() {
            const theme = themes[currentTheme];
            if (isRunning || isOvertime || isWarmingUp) {
                iconPlay.classList.add('hidden');
                iconStop.classList.remove('hidden');
                mainBtn.className = 'rounded-full text-white shadow-xl flex items-center justify-center transition-all transform duration-200 active:scale-95 mt-10 bg-black hover:bg-gray-900 shadow-slate-400 dark:shadow-slate-900';
            } else {
                iconPlay.classList.remove('hidden');
                iconStop.classList.add('hidden');
                updateThemeColors(); 
            }
            applySizes();
            mainBtn.style.opacity = mainBtnOpacity;
        }

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playBeep(freq, duration, type = 'sine') {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }
        
        function playSmootherBeep(freq, duration, volume) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle'; 
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            osc.start(now);
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration); 
            
            osc.stop(now + duration);
        }

        function playAlarmNote() {
            if (!soundEnabled || !audioCtx) return;
            
            const now = audioCtx.currentTime;
            const elapsed = now - alarmStartTime;
            const rampDuration = 3; 
            
            let vol = 0.1 + (elapsed / rampDuration) * 0.9;
            if (vol > 1.0) vol = 1.0;
            
            playSmootherBeep(880, 0.1, vol); 
            setTimeout(() => { playSmootherBeep(880, 0.1, vol); }, 150);
        }

        function toggleModal() {
            const isHidden = settingsModal.classList.contains('hidden');
            if (isHidden) settingsModal.classList.remove('hidden');
            else settingsModal.classList.add('hidden');
        }
        
        function updateSoundToggleUI() {
            const activeColor = 'bg-green-500';
            if (soundEnabled) {
                modalSoundToggle.classList.remove('bg-slate-200', 'dark:bg-slate-600');
                modalSoundToggle.classList.add(activeColor);
                soundToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
            } else {
                modalSoundToggle.classList.add('bg-slate-200');
                if(isDarkMode) modalSoundToggle.classList.add('dark:bg-slate-600');
                modalSoundToggle.classList.remove(activeColor);
                soundToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
            }
        }
        
        function updateDarkToggleUI() {
            const activeColor = 'bg-slate-900'; 
            if (isDarkMode) {
                modalDarkToggle.classList.remove('bg-slate-200', 'dark:bg-slate-600');
                modalDarkToggle.classList.add(activeColor);
                darkToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
            } else {
                modalDarkToggle.classList.add('bg-slate-200');
                modalDarkToggle.classList.remove(activeColor);
                darkToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
            }
        }
        
        function updateBoomToggleUI() {
            const activeColor = 'bg-yellow-500'; 
            if (isBoomMode) {
                modalBoomToggle.classList.remove('bg-slate-200', 'dark:bg-slate-600');
                modalBoomToggle.classList.add(activeColor);
                boomToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
            } else {
                modalBoomToggle.classList.add('bg-slate-200');
                if(isDarkMode) modalBoomToggle.classList.add('dark:bg-slate-600');
                modalBoomToggle.classList.remove(activeColor);
                boomToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
            }
        }
        
        function updateMinuteToggleUI() {
            const activeColor = 'bg-indigo-500';
            if (isMinuteMode) {
                modalMinuteToggle.classList.remove('bg-slate-200', 'dark:bg-slate-600');
                modalMinuteToggle.classList.add(activeColor);
                minuteToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
            } else {
                modalMinuteToggle.classList.add('bg-slate-200');
                if(isDarkMode) modalMinuteToggle.classList.add('dark:bg-slate-600');
                modalMinuteToggle.classList.remove(activeColor);
                minuteToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
            }
        }
        
        function updateScaleToggleUI() {
            const activeColor = 'bg-teal-500'; // Teal for scale
            if (tickPosition === 'outer') {
                modalScaleToggle.classList.remove('bg-slate-200', 'dark:bg-slate-600');
                modalScaleToggle.classList.add(activeColor);
                scaleToggleKnob.classList.replace('translate-x-1', 'translate-x-6');
                scaleLabel.textContent = "当前: 外侧";
            } else {
                modalScaleToggle.classList.add('bg-slate-200');
                if(isDarkMode) modalScaleToggle.classList.add('dark:bg-slate-600');
                modalScaleToggle.classList.remove(activeColor);
                scaleToggleKnob.classList.replace('translate-x-6', 'translate-x-1');
                scaleLabel.textContent = "当前: 内侧";
            }
        }

        settingsBtn.addEventListener('click', toggleModal);
        closeSettingsBtn.addEventListener('click', toggleModal);
        settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) toggleModal(); });
        restoreDefaultBtn.addEventListener('click', resetToDefaults);
        
        gotoInterfaceBtn.addEventListener('click', () => switchSettingsView('interface'));
        backToMainBtn.addEventListener('click', () => switchSettingsView('main'));

        modalSoundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            updateSoundToggleUI();
            initAudio(); 
            if(soundEnabled) playBeep(600, 0.1); 
        });
        
        modalDarkToggle.addEventListener('click', () => { toggleDarkMode(); initAudio(); });
        modalBoomToggle.addEventListener('click', () => { toggleBoomMode(); initAudio(); });
        modalMinuteToggle.addEventListener('click', () => { toggleMinuteMode(); initAudio(); });
        modalScaleToggle.addEventListener('click', () => { toggleScalePosition(); });
        
        opacityTimeSlider.addEventListener('input', (e) => {
            timeDisplayOpacity = e.target.value / 100;
            updateOpacityLabels();
            applyOpacities();
        });
        
        opacityBtnSlider.addEventListener('input', (e) => {
            mainBtnOpacity = e.target.value / 100;
            updateOpacityLabels();
            applyOpacities();
        });
        
        sizeTimeSlider.addEventListener('input', (e) => {
            timeFontSize = e.target.value / 10;
            updateSizeLabels();
            applySizes();
        });
        
        sizeBtnSlider.addEventListener('input', (e) => {
            mainBtnSize = e.target.value;
            updateSizeLabels();
            applySizes();
        });

        colorBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                setTheme(e.target.dataset.color);
                colorBtns.forEach(b => b.classList.remove('ring-2', 'ring-offset-2', 'dark:ring-offset-slate-800'));
                e.target.classList.add('ring-2', 'ring-offset-2', 'dark:ring-offset-slate-800');
            });
        });

        mainBtn.addEventListener('click', () => {
            if (isRunning || isOvertime || isWarmingUp) stopTimer();
            else startWarmupSequence(); 
        });

        init();

    </script>
</body>
    <script type="module" src="/index. tsx"></script>
</html>
